//
//  AWSUserFilesViewController.m
//  MySampleApp
//
//
// Copyright 2017 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to 
// copy, distribute and modify it.
//
// Source code generated from template: aws-my-sample-app-ios-objc v0.15
//
#import "UserFilesViewController.h"

#import <MediaPlayer/MediaPlayer.h>
#import <AWSMobileHubHelper/AWSMobileHubHelper.h>

NSString *const UserFilesPublicDirectoryName = @"public";
NSString *const UserFilesPrivateDirectoryName = @"private";
NSString *const UserFilesProtectedDirectoryName = @"protected";
NSString *const UserFilesUploadsDirectoryName = @"uploads";

@interface UserFilesViewController () <UINavigationControllerDelegate, UIImagePickerControllerDelegate>

@property (nonatomic, strong) AWSUserFileManager *manager;

@property (nonatomic, strong) NSArray *contents;
@property (nonatomic, strong) NSDateFormatter *dateFormatter;

@property (nonatomic, strong) NSString *marker;
@property (nonatomic, assign) BOOL didLoadAllContents;

@end

@interface NSString (UserFilesViewController)

+ (NSString *)aws_stringFromByteCount:(NSUInteger)byteCount;

@end

@implementation UserFilesViewController

#pragma mark - View lifecycle

- (void)viewDidLoad {
    [super viewDidLoad];

    self.manager = [AWSUserFileManager defaultUserFileManager];

    // Sets up the UIs.
    self.navigationItem.rightBarButtonItem =
        [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction
                                                      target:self
                                                      action:@selector(showContentManagerActionOptions:)];
    // Sets up the date formatter.
    self.dateFormatter = [NSDateFormatter new];
    self.dateFormatter.dateStyle = kCFDateFormatterShortStyle;
    self.dateFormatter.timeStyle = kCFDateFormatterShortStyle;
    self.dateFormatter.locale = [NSLocale currentLocale];

    self.tableView.estimatedRowHeight = self.tableView.rowHeight;
    self.tableView.rowHeight = UITableViewAutomaticDimension;

    if (!self.prefix) {
        self.prefix = [NSString stringWithFormat:@"%@/", UserFilesPublicDirectoryName];
    }

    [self updateUserInterface];
    [self loadMoreContents];
}

- (void)updateUserInterface {
    self.cacheLimitLabel.text = [NSString aws_stringFromByteCount:self.manager.maxCacheSize];
    self.currentCacheSizeLabel.text = [NSString aws_stringFromByteCount:self.manager.cachedUsedSize];
    self.availableCacheSizeLabel.text = [NSString aws_stringFromByteCount:self.manager.maxCacheSize - self.manager.cachedUsedSize];
    self.pinnedCacheSizeLabel.text = [NSString aws_stringFromByteCount:self.manager.pinnedSize];

    if (self.prefix) {
        NSString *pathText = [NSString stringWithFormat:@"%@", self.prefix];
        NSInteger pathStartFromIndex = 0;
        NSInteger maxPathTextLength = 50;
        
        if ([self.prefix hasPrefix:UserFilesPublicDirectoryName]) {
            pathStartFromIndex = UserFilesPublicDirectoryName.length;
        } else if ([self.prefix hasPrefix:UserFilesPrivateDirectoryName]) {
            NSString *userId = [AWSIdentityManager defaultIdentityManager].identityId;
            pathStartFromIndex = UserFilesPrivateDirectoryName.length + userId.length + 1;
        } else if ([self.prefix hasPrefix:UserFilesProtectedDirectoryName]) {
            pathStartFromIndex = UserFilesProtectedDirectoryName.length;
        } else if ([self.prefix hasPrefix:UserFilesUploadsDirectoryName]) {
            pathStartFromIndex = UserFilesUploadsDirectoryName.length;
        }
        
        if (pathText.length > maxPathTextLength + pathStartFromIndex) {
            pathStartFromIndex = pathText.length - maxPathTextLength;
            self.pathLabel.text = [NSString stringWithFormat:@"...%@", [pathText substringFromIndex:pathStartFromIndex]];
        } else {
            self.pathLabel.text = [pathText substringFromIndex:pathStartFromIndex];
        }
    } else {
        self.pathLabel.text = @"/";
    }

    [self.segmentedControl setSelectedSegmentIndex:self.segmentedIndex];
    [self.tableView reloadData];
}

#pragma mark - Content Manager user action methods

- (IBAction)changeDirectory:(UISegmentedControl *)sender {
    switch (sender.selectedSegmentIndex) {
        case 0: // Public directory
            self.manager = [AWSUserFileManager defaultUserFileManager];
            self.prefix = [NSString stringWithFormat:@"%@/", UserFilesPublicDirectoryName];
            break;
        case 1: { // Private directory
            if ([[AWSIdentityManager defaultIdentityManager] isLoggedIn]) {
                self.manager = [AWSUserFileManager defaultUserFileManager];
                NSString *userId = [AWSIdentityManager defaultIdentityManager].identityId;
                self.prefix = [NSString stringWithFormat:@"%@/%@/", UserFilesPrivateDirectoryName, userId];
            } else {
                sender.selectedSegmentIndex = self.segmentedIndex;
                __weak UserFilesViewController *weakSelf = self;
                UIAlertController *alertController =
                    [UIAlertController alertControllerWithTitle:nil
                                                        message:@"Private user file storage is only available to users who are signed-in. Would you like to sign in?"
                                                 preferredStyle:UIAlertControllerStyleAlert];
                UIAlertAction *signInAction =
                    [UIAlertAction actionWithTitle:@"Sign In"
                                             style:UIAlertActionStyleDefault
                                           handler:^(UIAlertAction * _Nonnull action) {
                                                       UIStoryboard *loginStoryboard =
                                                           [UIStoryboard storyboardWithName:@"SignIn" bundle:nil];

                                                       UIViewController *loginController =
                                                           [loginStoryboard instantiateViewControllerWithIdentifier:@"SignIn"];

                                                       [weakSelf.navigationController pushViewController:loginController
                                                                                                animated:YES];
                                                   }];
                [alertController addAction:signInAction];

                UIAlertAction *cancelAction =
                    [UIAlertAction actionWithTitle:@"Cancel"
                                             style:UIAlertActionStyleCancel
                                           handler:nil];
                [alertController addAction:cancelAction];

                [self presentViewController:alertController
                                   animated:YES
                                 completion:nil];
            }

            break;
        }
        case 2: // Protected directory
            self.manager = [AWSUserFileManager defaultUserFileManager];
            if (![[AWSIdentityManager defaultIdentityManager] isLoggedIn]) {
                self.prefix = [NSString stringWithFormat:@"%@/", UserFilesProtectedDirectoryName];
            } else {
                NSString *userId = [AWSIdentityManager defaultIdentityManager].identityId;
                self.prefix = [NSString stringWithFormat:@"%@/%@/", UserFilesProtectedDirectoryName, userId];
            }
            break;
        case 3: // Uploads directory
            self.manager = [AWSUserFileManager defaultUserFileManager];
            self.prefix = [NSString stringWithFormat:@"%@/", UserFilesUploadsDirectoryName];
            break;
        default:
            break;
    }

    self.segmentedIndex = sender.selectedSegmentIndex;
    self.contents = [NSArray new];
    [self loadMoreContents];
}

- (void)showContentManagerActionOptions:(id)sender {
    UIAlertController *alertController =
        [UIAlertController alertControllerWithTitle:nil
                                            message:nil
                                     preferredStyle:UIAlertControllerStyleActionSheet];

    __weak UserFilesViewController *weakSelf = self;
    UIAlertAction *uploadObjectAction =
        [UIAlertAction actionWithTitle:@"Upload"
                                 style:UIAlertActionStyleDefault
                                handler:^(UIAlertAction *action) {
                                    [weakSelf showImagePicker];
                                }];
    [alertController addAction:uploadObjectAction];

    UIAlertAction *createFolderAction =
        [UIAlertAction actionWithTitle:@"New Folder"
                                 style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction *action) {
                                   [weakSelf askForDirectoryName];
                               }];
    [alertController addAction:createFolderAction];

    UIAlertAction *refreshAction =
        [UIAlertAction actionWithTitle:@"Refresh"
                                 style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction *action) {
                                   [weakSelf refreshContents];
                               }];
    [alertController addAction:refreshAction];

    UIAlertAction *downloadObjectsAction =
        [UIAlertAction actionWithTitle:@"Download Recent"
                                 style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction *action) {
                                   [weakSelf downloadObjectsToFillCache];
                               }];
    [alertController addAction:downloadObjectsAction];

    UIAlertAction *changeLimitAction =
        [UIAlertAction actionWithTitle:@"Set Cache Size"
                                 style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction *action) {
                                   [weakSelf showDiskLimitOptions];
                               }];
    [alertController addAction:changeLimitAction];



    UIAlertAction *removeAllObjectsAction =
        [UIAlertAction actionWithTitle:@"Clear Cache"
                                 style:UIAlertActionStyleDestructive
                               handler:^(UIAlertAction *action) {
                                   [weakSelf.manager clearCache];
                                   [weakSelf updateUserInterface];
                               }];
    [alertController addAction:removeAllObjectsAction];

    UIAlertAction *cancelAction =
        [UIAlertAction actionWithTitle:@"Cancel"
                                 style:UIAlertActionStyleCancel
                               handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (void)refreshContents {
    self.marker = nil;
    [self loadMoreContents];
}

- (void)loadMoreContents {
    __weak UserFilesViewController *weakSelf = self;
    if ([weakSelf isPrefixUploadsFolder]) { // Uploads folder is write-only, no content to list
        [weakSelf updateUserInterface];
        return;
    }
    
    [self.manager
        listAvailableContentsWithPrefix:self.prefix
                                marker:self.marker
                    completionHandler:^(NSArray *contents, NSString *nextMarker, NSError *error) {
                        if (error) {
                            [weakSelf showSimpleAlertWithTitle:@"Error"
                                                       message:@"Failed to load the list of contents."
                                             cancelButtonTitle:@"Okay"];
                                NSLog(@"Failed to load the list of contents. %@", error);
                        }
                        if (contents.count > 0) {
                            weakSelf.contents = contents;
                            weakSelf.didLoadAllContents = !nextMarker;
                            weakSelf.marker = nextMarker;
                        } else {
                            if ([weakSelf isPrefixUserProtectedFolder]) {
                                [weakSelf checkUserProtectedFolder];
                            } else {
                                [weakSelf updateUserInterface];
                            }
                        }
                        [weakSelf updateUserInterface];
                    }];
}

- (void)showDiskLimitOptions {
    __weak UserFilesViewController *weakSelf = self;
    UIAlertController *alertController =
        [UIAlertController alertControllerWithTitle:@"Disk Cache Size"
                                            message:nil
                                     preferredStyle:UIAlertControllerStyleActionSheet];

    for (NSNumber *number in @[@1, @5, @20, @50, @100]) {
        UIAlertAction *byteLimitOptionAction =
            [UIAlertAction actionWithTitle:
                [NSString
                    stringWithFormat:@"%@ MB", number]
                               style:UIAlertActionStyleDefault
                             handler:^(UIAlertAction *action) {
                                 weakSelf.manager.maxCacheSize = [number unsignedIntegerValue] * 1024 * 1024;
                                 [weakSelf updateUserInterface];
                             }];
        [alertController addAction:byteLimitOptionAction];
    }

    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel"
                                                           style:UIAlertActionStyleCancel
                                                         handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (void)downloadObjectsToFillCache {
    __weak UserFilesViewController *weakSelf = self;
    [self.manager listRecentContentsWithPrefix:self.prefix
                             completionHandler:^(id result, NSError *error) {
                                                   for (AWSContent *content in result) {
                                                       if (!content.isCached
                                                           && !content.isDirectory) {
                                                           [weakSelf downloadContent:content
                                                                     pinOnCompletion:NO];
                                                       }
                                                   }
                                               }];
}

#pragma mark - Content user action methods

- (void)showActionOptionsForContent:(CGRect)rect content:(AWSContent *)content {
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil
                                                                             message:nil
                                                                      preferredStyle:UIAlertControllerStyleActionSheet];
    if (alertController.popoverPresentationController != nil) {
        alertController.popoverPresentationController.sourceView = self.view;
        alertController.popoverPresentationController.sourceRect = CGRectMake(rect.origin.x + (rect.size.width/2.0),
                                                                              rect.origin.y + (rect.size.height/2.0),
                                                                              1.0,
                                                                              1.0);
    }
    __weak UserFilesViewController *weakSelf = self;

    if (content.isCached) {
        UIAlertAction *openAction = [UIAlertAction actionWithTitle:@"Open"
                                                             style:UIAlertActionStyleDefault
                                                           handler:^(UIAlertAction *action) {
                                                               dispatch_async(dispatch_get_main_queue(), ^{
                                                                   [weakSelf openContent:content];
                                                               });
                                                           }];
        [alertController addAction:openAction];
    }
    
    // Allow opening of remote files natively or in browser based on their type.
    UIAlertAction *openRemoteAction = [UIAlertAction actionWithTitle:@"Open Remote Content"
                                                             style:UIAlertActionStyleDefault
                                                           handler:^(UIAlertAction *action) {
                                                               dispatch_async(dispatch_get_main_queue(), ^{
                                                                   [weakSelf openRemoteContent:content];
                                                               });
                                                           }];
    [alertController addAction:openRemoteAction];

    // If the content hasn't been downloaded, and it's larger than the limit of the cache,
    // we don't allow downloading the contentn.
    if (content.knownRemoteByteCount + 4 * 1024 < self.manager.maxCacheSize) { // 4 KB is for local metadata.
        NSString *title = @"Download";
        if ([content.knownRemoteLastModifiedDate compare:content.downloadedDate] == NSOrderedDescending) {
            title = @"Download Latest Version";
        }
        UIAlertAction *downloadAction = [UIAlertAction actionWithTitle:title
                                                                 style:UIAlertActionStyleDefault
                                                               handler:^(UIAlertAction *action) {
                                                                   [weakSelf downloadContent:content
                                                                             pinOnCompletion:NO];
                                                               }];
        [alertController addAction:downloadAction];
    }

    UIAlertAction *downloadAndPinAction = [UIAlertAction actionWithTitle:@"Download & Pin"
                                                                   style:UIAlertActionStyleDefault
                                                                 handler:^(UIAlertAction *action) {
                                                                     [weakSelf downloadContent:content
                                                                               pinOnCompletion:YES];
                                                                 }];
    [alertController addAction:downloadAndPinAction];

    if (content.isCached) {
        if (content.isPinned) {
            UIAlertAction *unpinAction = [UIAlertAction actionWithTitle:@"Unpin"
                                                                  style:UIAlertActionStyleDefault
                                                                handler:^(UIAlertAction *action) {
                                                                    [content unPin];
                                                                    [weakSelf updateUserInterface];
                                                                }];
            [alertController addAction:unpinAction];
        } else {
            UIAlertAction *pinAction = [UIAlertAction actionWithTitle:@"Pin"
                                                                style:UIAlertActionStyleDefault
                                                              handler:^(UIAlertAction *action) {
                                                                  [content pin];
                                                                  [weakSelf updateUserInterface];
                                                              }];
            [alertController addAction:pinAction];
        }

        UIAlertAction *removeAction =
            [UIAlertAction actionWithTitle:@"Delete Local Copy"
                                     style:UIAlertActionStyleDestructive
                                   handler:^(UIAlertAction *action) {
                                               [content removeLocal];
                                               [weakSelf updateUserInterface];
                                           }];
        [alertController addAction:removeAction];
    }

    UIAlertAction *removeFromRemoteAction = [UIAlertAction actionWithTitle:@"Delete Remote File"
                                                                     style:UIAlertActionStyleDestructive
                                                                   handler:^(UIAlertAction * _Nonnull action) {
                                                                       [weakSelf confirmForRemovingContent:content];
                                                                   }];
    [alertController addAction:removeFromRemoteAction];

    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel"
                                                           style:UIAlertActionStyleCancel
                                                         handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (void)downloadContent:(AWSContent *)content
        pinOnCompletion:(BOOL)pinOnCompletion {
    __weak UserFilesViewController *weakSelf = self;
    [content downloadWithDownloadType:AWSContentDownloadTypeIfNewerExists
                      pinOnCompletion:pinOnCompletion
                        progressBlock:^(AWSContent *content, NSProgress *progress) {
                            if ([weakSelf.contents containsObject:content]) {
                                [weakSelf.tableView reloadData];
                            }
                        }
                    completionHandler:^(AWSContent *content, NSData *data, NSError *error) {
                        if (error) {
                            NSLog(@"Failed to download a content from a server. %@", error);
                            [weakSelf showSimpleAlertWithTitle:@"Error"
                                                       message:@"Failed to download a content from a server."
                                             cancelButtonTitle:@"Okay"];
                        }

                        [weakSelf updateUserInterface];
                    }];
}

- (void)openRemoteContent:(AWSContent *)content {
    __weak UserFilesViewController *weakSelf = self;
    [content getRemoteFileURLWithCompletionHandler:^(NSURL *url, NSError *error) {
        if (error) {
            NSLog(@"Failed to get a valid URL from a server. %@", error);
            [weakSelf showSimpleAlertWithTitle:@"Error"
                                       message:@"Failed to get a valid URL from a server."
                             cancelButtonTitle:@"OK"];
        }
        if (url) {
            if ([weakSelf isAudioVideoFile:content]) {
                MPMoviePlayerViewController *controller = [[MPMoviePlayerViewController alloc]initWithContentURL: url];
                [controller.moviePlayer prepareToPlay];
                [controller.moviePlayer play];
                
                [weakSelf presentMoviePlayerViewControllerAnimated:controller];
            } else {
                [[UIApplication sharedApplication] openURL:url];
            }

        }
    }];
}

- (void)openContent:(AWSContent *)content {
    if ([self isAudioVideoFile:content]) { // Video and sound files
        NSArray *directories = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
        NSString *cacheDirectoryPath = [directories firstObject];
        NSURL *movieURL = [NSURL fileURLWithPath:[cacheDirectoryPath stringByAppendingPathComponent:[content.key lastPathComponent]]];
        [content.cachedData writeToURL:movieURL atomically:YES];

        MPMoviePlayerViewController *controller = [[MPMoviePlayerViewController alloc]initWithContentURL:movieURL];
        [controller.moviePlayer prepareToPlay];
        [controller.moviePlayer play];

        [self presentMoviePlayerViewControllerAnimated:controller];
    } else if ([content.key hasSuffix:@".jpg"]
               || [content.key hasSuffix:@".png"]) { // Image files
        UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"UserFiles" bundle:nil];
        UserFilesImageViewController *imageViewController = [storyboard instantiateViewControllerWithIdentifier:@"UserFilesImageViewController"];
        imageViewController.image = [UIImage imageWithData:content.cachedData];
        imageViewController.title = content.key;

        [self.navigationController pushViewController:imageViewController
                                             animated:YES];
    } else {
        [self showSimpleAlertWithTitle:@"Sorry!"
                               message:@"We can only open image, video, and sound files."
                     cancelButtonTitle:@"Okay"];
    }
}

- (void)confirmForRemovingContent:(AWSContent *)content {
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Confirm"
                                                                             message:@"Do you want to delete the content from the server? This cannot be undone."
                                                                      preferredStyle:UIAlertControllerStyleAlert];

    __weak UserFilesViewController *weakSelf = self;
    UIAlertAction *okayAction = [UIAlertAction actionWithTitle:@"Yes"
                                                         style:UIAlertActionStyleDefault
                                                       handler:^(UIAlertAction * _Nonnull action) {
                                                           [weakSelf removeContent:content];
                                                       }];
    [alertController addAction:okayAction];

    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel"
                                                           style:UIAlertActionStyleCancel
                                                         handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (void)removeContent:(AWSContent *)content {
    [content removeRemoteContentWithCompletionHandler:^(AWSContent *content, NSError *error) {
        if (error) {
            NSLog(@"Failed to delete an object from the remote server. %@", error);
            [self showSimpleAlertWithTitle:@"Error"
                                   message:@"Failed to delete an object from the remote server."
                         cancelButtonTitle:@"Okay"];
        } else {
            [self showSimpleAlertWithTitle:@"Object Deleted"
                                   message:@"The object has been deleted successfully."
                         cancelButtonTitle:@"Okay"];
            [self refreshContents];
        }
    }];
}

#pragma mark - Content uploads

- (void)showImagePicker {
    UIImagePickerController *imagePickerController = [UIImagePickerController new];
    imagePickerController.delegate = self;
    [self presentViewController:imagePickerController
                       animated:YES
                     completion:nil];
}

- (void)askForFilename:(NSData *)data {
    UIAlertController *alertController =
        [UIAlertController alertControllerWithTitle:@"File Name"
                                            message:@"Please specify the file name."
                                     preferredStyle:UIAlertControllerStyleAlert];
    [alertController addTextFieldWithConfigurationHandler:nil];

    __weak UserFilesViewController *weakSelf = self;
    UIAlertAction *doneAction =
        [UIAlertAction actionWithTitle:@"Done"
                                 style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction * _Nonnull action) {
                                   NSString *specifiedKey = alertController.textFields.firstObject.text;
                                   if (specifiedKey.length == 0) {
                                       [weakSelf showSimpleAlertWithTitle:@"Error"
                                                                  message:@"The file name cannot be empty."
                                                        cancelButtonTitle:@"Okay"];
                                       return;
                                   } else {
                                       NSString *key = [NSString stringWithFormat:@"%@%@", self.prefix, specifiedKey];
                                       [weakSelf uploadWithData:data forKey:key];
                                   }
                               }];
    [alertController addAction:doneAction];

    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel"
                                                           style:UIAlertActionStyleCancel
                                                         handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (void)askForDirectoryName {
    UIAlertController *alertController =
        [UIAlertController alertControllerWithTitle:@"Directory Name"
                                            message:@"Please specify the directory name."
                                     preferredStyle:UIAlertControllerStyleAlert];
    [alertController addTextFieldWithConfigurationHandler:nil];

    __weak UserFilesViewController *weakSelf = self;
    UIAlertAction *doneAction =
        [UIAlertAction actionWithTitle:@"Done"
                                 style:UIAlertActionStyleDefault
                               handler:^(UIAlertAction * _Nonnull action) {
                                   NSString *specifiedKey = alertController.textFields.firstObject.text;
                                   if (specifiedKey.length == 0) {
                                       [weakSelf showSimpleAlertWithTitle:@"Error"
                                                                  message:@"The directory name cannot be empty."
                                                        cancelButtonTitle:@"Okay"];
                                       return;
                                   } else {
                                       NSString *key = [NSString stringWithFormat:@"%@%@/", self.prefix, specifiedKey];
                                       [weakSelf createFolderForKey:key];
                                   }
                               }];
    [alertController addAction:doneAction];

    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel"
                                                           style:UIAlertActionStyleCancel
                                                         handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (void)uploadLocalContent:(AWSLocalContent*)localContent {
    __weak UserFilesViewController *weakSelf = self;
    [localContent uploadWithPinOnCompletion:NO
                              progressBlock:^(AWSLocalContent *content, NSProgress *progress) {
                                  if ([weakSelf.manager.uploadingContents containsObject:content]) {
                                      [weakSelf.tableView reloadData];
                                  }
                              }
                          completionHandler:^(AWSContent *content, NSError *error) {
                              [weakSelf.tableView reloadData];
                              if (error) {
                                  NSLog(@"Failed to upload an object. %@", error);
                                  [weakSelf showSimpleAlertWithTitle:@"Error"
                                                             message:@"Failed to upload an object."
                                                   cancelButtonTitle:@"Okay"];
                              } else {
                                  if ([localContent.key hasPrefix:UserFilesUploadsDirectoryName]) {
                                      [weakSelf showSimpleAlertWithTitle:@"File upload"
                                                                 message:[NSString stringWithFormat:@"File upload completed successfully for %@.", localContent.key]
                                                       cancelButtonTitle:@"Okay"];
                                  }
                                  [weakSelf refreshContents];
                              }
                          }];
}

- (void)uploadWithData:(NSData *)data forKey:(NSString *)key {
    AWSLocalContent *localContent = [self.manager localContentWithData:data key:key];
    [self uploadLocalContent:localContent];
}

- (void)createFolderForKey:(NSString *)key {
    AWSLocalContent *localContent = [self.manager localContentWithData:nil key:key];
    [self uploadLocalContent:localContent];
}

- (void)updateUploadUI {
    [self.tableView reloadSections:[NSIndexSet indexSetWithIndex:0]
                  withRowAnimation:UITableViewRowAnimationAutomatic];
}

#pragma mark - UIImagePickerControllerDelegate

- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info {
    [self dismissViewControllerAnimated:YES completion:nil];

    if ([@"public.image" isEqualToString:info[UIImagePickerControllerMediaType]]) {
        UIImage *image = info[UIImagePickerControllerOriginalImage];
        [self askForFilename:UIImagePNGRepresentation(image)];
    }
}

#pragma mark - UITableViewDataSource

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 2;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    if (section == 0) {
        return [self.manager.uploadingContents count];
    }
    if ([self isPrefixUploadsFolder]) {
        return 1;
    } else if ([self isPrefixUserProtectedFolder]) {
        return [self.contents count] + 1;
    } else {
        return [self.contents count];
    }
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    if (indexPath.section == 0) {
        UserFilesUploadCell *cell = [tableView dequeueReusableCellWithIdentifier:@"UserFilesUploadCell"
                                                                    forIndexPath:indexPath];
        AWSLocalContent *localContent = self.manager.uploadingContents[indexPath.row];

        cell.prefix = self.prefix;
        cell.localContent = localContent;

        return cell;
    }

    UserFilesCell *cell = [tableView dequeueReusableCellWithIdentifier:@"UserFilesCell"
                                                          forIndexPath:indexPath];
    AWSContent *content = nil;
    if ([self isPrefixUserProtectedFolder] || [self isPrefixUploadsFolder]) {
        if ([self isPrefixUserProtectedFolder] && indexPath.row > 0 && indexPath.row < self.contents.count + 1) {
            content = self.contents[indexPath.row - 1];
        }
    } else {
        if (indexPath.row < self.contents.count) {
            content = self.contents[indexPath.row];
        }
    }
    
    cell.prefix = self.prefix;
    cell.content = content;
    
    if ([self isPrefixUserProtectedFolder] && indexPath.row == 0) {
        cell.fileNameLabel.text = @"..";
        cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
        cell.detailLabel.text = @"This is a folder";
    } else if ([self isPrefixUploadsFolder]) {
        cell.fileNameLabel.text = @"This folder is write only";
        cell.accessoryType = UITableViewCellAccessoryNone;
        cell.detailLabel.text = @"";
    }

    return cell;
}

- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {
    if (indexPath.row == self.contents.count - 1) {
        if (!self.didLoadAllContents) {
            [self loadMoreContents];
        }
    }
}

#pragma mark - UITableViewDelegate

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath
                             animated:YES];
    __weak UserFilesViewController *weakSelf = self;
    AWSContent *content = nil;
    
    if ([self isPrefixUploadsFolder]) {
        [weakSelf showImagePicker];
        return;
    } else if (![self isPrefixUserProtectedFolder]) {
        content = self.contents[indexPath.row];
    } else {
        if (indexPath.row > 0) {
            content = self.contents[indexPath.row - 1];
        } else {
            // The first cell of the user protected folder file list is used to go one directory up (i.e., protected/)
            UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"UserFiles"
                                                                 bundle:nil];
            UserFilesViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:@"UserFiles"];
            viewController.prefix = [NSString stringWithFormat:@"%@/", UserFilesProtectedDirectoryName];
            viewController.segmentedIndex = self.segmentedIndex;
            
            [self.navigationController pushViewController:viewController
                                                 animated:YES];
            return;
        }
    }
    
    if (content.isDirectory) {
        UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"UserFiles"
                                                             bundle:nil];
        UserFilesViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:@"UserFiles"];
        viewController.prefix = content.key;
        viewController.segmentedIndex = self.segmentedIndex;
        [self.navigationController pushViewController:viewController
                                             animated:YES];
    } else {
        CGRect rowRect = [tableView rectForRowAtIndexPath:indexPath];
        [self showActionOptionsForContent:rowRect content:content];
    }
}

#pragma mark - Utility

- (void)checkUserProtectedFolder {
    NSString *userId = [AWSIdentityManager defaultIdentityManager].identityId;
    NSString *prefixUserProtectedFolder = [NSString stringWithFormat:@"%@/%@/", UserFilesProtectedDirectoryName, userId];
    __weak UserFilesViewController *weakSelf = self;
    
    if ([[AWSIdentityManager defaultIdentityManager] isLoggedIn] && [self.prefix isEqualToString:prefixUserProtectedFolder]) {
        AWSLocalContent *localContent = [self.manager localContentWithData:nil key:prefixUserProtectedFolder];
        [localContent uploadWithPinOnCompletion:NO
                                  progressBlock:^(AWSLocalContent *content, NSProgress *progress) {
                                  }
                              completionHandler:^(AWSContent *content, NSError *error) {
                                  if (!error) {
                                      [weakSelf updateUserInterface];
                                  } else {
                                      [weakSelf showSimpleAlertWithTitle:@"Error"
                                                                 message:@"Failed to load the list of contents."
                                                       cancelButtonTitle:@"Okay"];
                                      self.prefix = UserFilesPublicDirectoryName;
                                      self.segmentedIndex = 0;
                                      self.contents = [NSArray new];
                                      [self loadMoreContents];
                                      NSLog(@"Failed to load the list of contents. %@", error);
                                  }
                              }];
    } else {
        [weakSelf updateUserInterface];
    }
    
}

- (BOOL) isPrefixUserProtectedFolder {
    NSString *userId = [AWSIdentityManager defaultIdentityManager].identityId;
    NSString *pathToMyProtected = [NSString stringWithFormat:@"%@/%@/", UserFilesProtectedDirectoryName, userId];
    return [self.prefix isEqualToString:pathToMyProtected];
}

- (BOOL) isPrefixUploadsFolder {
    NSString *pathToUploads = [NSString stringWithFormat:@"%@/", UserFilesUploadsDirectoryName];
    return [self.prefix isEqualToString:pathToUploads];
}

- (void)showSimpleAlertWithTitle:(NSString *)title
                         message:(NSString *)message
               cancelButtonTitle:(NSString *)cancelTitle {
    UIAlertController *alertController =
        [UIAlertController alertControllerWithTitle:title
                                            message:message
                                     preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction *cancelAction =
        [UIAlertAction actionWithTitle:cancelTitle
                                 style:UIAlertActionStyleCancel
                               handler:nil];
    [alertController addAction:cancelAction];

    [self presentViewController:alertController
                       animated:YES
                     completion:nil];
}

- (BOOL)isAudioVideoFile:(AWSContent *) content {
    NSString *fileName = [content.key lowercaseString];
    return ([fileName hasSuffix:@".mov"]
        || [fileName hasSuffix:@".m4p"]
        || [fileName hasSuffix:@".m4v"]
        || [fileName hasSuffix:@".mp4"]
        || [fileName hasSuffix:@".mpv"]
        || [fileName hasSuffix:@".3gp"]
        || [fileName hasSuffix:@".mpeg"]
        || [fileName hasSuffix:@".aac"]
        || [fileName hasSuffix:@".mp3"]);
}

@end

@implementation UserFilesCell

- (void)setContent:(AWSContent *)content {
    if (!content) {
        self.fileNameLabel.text = @"";
        self.detailLabel.text = @"";
        self.downloadedImageView.hidden = YES;
        self.keepImageView.hidden = YES;
        self.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
        self.detailLabel.textColor = [UIColor blackColor];
        self.progressView.hidden = YES;
        return;
    }
    
    NSString *displayFilename = content.key;
    if (self.prefix && displayFilename.length > self.prefix.length) {
        displayFilename = [displayFilename substringFromIndex:self.prefix.length];
    }
    self.fileNameLabel.text = displayFilename;

    self.downloadedImageView.hidden = !content.isCached;
    self.keepImageView.hidden = !content.isPinned;

    NSUInteger contentByteCount = content.fileSize;
    if (contentByteCount == 0) {
        contentByteCount = content.knownRemoteByteCount;
    }
    if (content.isDirectory) {
        self.detailLabel.text = @"This is a folder";
        self.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
    } else {
        self.detailLabel.text = [NSString aws_stringFromByteCount:contentByteCount];
        self.accessoryType = UITableViewCellAccessoryNone;
    }
    if ([content.knownRemoteLastModifiedDate compare:content.downloadedDate] == NSOrderedDescending) {
        self.detailLabel.text = [NSString stringWithFormat:@"%@ - New Version Available", self.detailLabel.text];
        self.detailLabel.textColor = [UIColor blueColor];
    } else {
        self.detailLabel.textColor = [UIColor blackColor];
    }

    if (content.status == AWSContentStatusTypeRunning) {
        self.progressView.progress = content.progress.fractionCompleted;
        self.progressView.hidden = NO;
    } else {
        self.progressView.hidden = YES;
    }
}

@end

@implementation UserFilesImageViewController

- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];

    self.imageView.image = self.image;
}

@end

@implementation NSString (AWSUserFilesViewController)

+ (NSString *)aws_stringFromByteCount:(NSUInteger)byteCount {
    if (byteCount < 1024) {
        return [NSString stringWithFormat:@"%lu B", (unsigned long)byteCount];
    }
    if (byteCount < 1024 * 1024) {
        return [NSString stringWithFormat:@"%lu KB", (unsigned long)byteCount / 1024];
    }
    if (byteCount < 1024 * 1024 * 1024) {
        return [NSString stringWithFormat:@"%lu MB", (unsigned long)byteCount / 1024 / 1024];
    }
    return [NSString stringWithFormat:@"%lu GB", (unsigned long)byteCount / 1024 / 1024 / 1024];
}

@end

@implementation UserFilesUploadCell

- (void)setLocalContent:(AWSLocalContent *)localContent {
    NSString *displayFilename = localContent.key;
    if (self.prefix && [displayFilename hasPrefix:self.prefix]) {
        displayFilename = [displayFilename substringFromIndex:self.prefix.length];
    }
    self.fileNameLabel.text = displayFilename;
    self.progressView.progress = localContent.progress.fractionCompleted;
}

@end
